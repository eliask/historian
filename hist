#! /usr/bin/env bash

typeset -r \
    VERSION="0.1.0" \
    HISTORIAN_SRC=${HISTORIAN_SRC-"${HOME}/.bash_history"} \
    HISTORIAN_DB=${HISTORIAN_DB-"${HOME}/.historian.db"} \
    HISTORIAN_SQLITE3=${HISTORIAN_SQLITE3-"$(which sqlite3)"} \
    MAGIC_ENUM_QUOTE=1 \
    MAGIC="$(echo -e "\x10\x83\xB9\x9F\x34\xB5\x96\x45")" # 0118 999 881 999 119 725 3

usage() {
    cat >&2 <<EOF
Usage: hist <subcommand>
subcommands:
  config            show config
  count             count items in history
  import            import to db
  shell             launch sqlite3 shell with db
  search <terms...> search for one or more search terms
    /term           search for <term>
  version           show the version
EOF
}

historian_sqlite() {
    "${HISTORIAN_SQLITE3}" "${HISTORIAN_DB}"
}

preflight_check() {
    if [ -z "$HOME" ]; then
        echo "need \$HOME" >&2
        exit 1
    fi

    if [ -z "${HISTORIAN_SQLITE3}" ]; then
        echo "need sqlite3" >&2
        exit 1
    fi
}

ensure_db_exists() {
    historian_sqlite <<SQL
        CREATE TABLE IF NOT EXISTS history (
            id INTEGER PRIMARY KEY ASC,
            command TEXT NOT NULL,
            timestamp INTEGER
        );
        CREATE UNIQUE INDEX IF NOT EXISTS
            history_command_timestamp ON history(command);
        CREATE VIRTUAL TABLE IF NOT EXISTS
            history_search USING fts4(id, history, command);
SQL
}

get_magic() {
    local -ri idx=$1
    echo -n "${MAGIC}$(echo -ne "\x$((idx + 11))")"
}

fail_unless_db_exists() {
    if [ ! -f "${HISTORIAN_DB}" ]; then
        echo "db (${HISTORIAN_DB}) doesn't exist. Aborting";
        exit 1;
    fi
}

cmd_config() {
    cat <<EOF
version:        ${VERSION}
source_history: ${HISTORIAN_SRC}
db:             ${HISTORIAN_DB}
sqlite3:        ${HISTORIAN_SQLITE3}
EOF
}

cmd_count() {
    preflight_check
    ensure_db_exists

    historian_sqlite <<< 'SELECT COUNT(*) FROM history;'
}

cmd_import() {
    preflight_check
    ensure_db_exists

    local -r column_separator=$(echo -e "\x01")
    local -r magic=$(get_magic "${MAGIC_ENUM_QUOTE}")
    readonly sanitized_src=$(mktemp)

    cleanup() { rm -f "$sanitized_src"; }
    trap cleanup EXIT

    sed -e 's/"/'"$magic"'/g' \
        < "${HISTORIAN_SRC}" \
        > "${sanitized_src}"

    historian_sqlite <<SQL
        CREATE TEMPORARY TABLE variables
            (key TEXT, value INTEGER);
        INSERT INTO variables(key, value)
            SELECT 'items', COUNT(*) FROM history;
        CREATE TEMPORARY TABLE history_import (line TEXT);
.separator $column_separator
.import ${sanitized_src} history_import
        UPDATE history_import
            SET line = REPLACE(line, '$magic', '"');
        INSERT OR IGNORE INTO history(command, timestamp)
            SELECT line, NULL FROM history_import;
        SELECT 'Imported '
            || (SELECT COUNT(*) - value FROM history)
            || ' item(s).'
            FROM variables WHERE key = 'items';
SQL
}

cmd_log() {
    preflight_check
    fail_unless_db_exists

    historian_sqlite <<SQL | less
.separator "\\n\\t"
        SELECT id, command
        FROM history
        ORDER BY id DESC;
SQL
}

cmd_search() {
    preflight_check
    ensure_db_exists

    local -r args=( "$@" )
    search_terms() {
        for term in "${args[@]}"; do
            local quoted_term=${term//\'/\'\'}
            echo "AND command LIKE '%${quoted_term}%'"
        done
    }

    historian_sqlite <<SQL
.separator "\\n\\t"
        SELECT id, command
        FROM history
        WHERE 1
        $(search_terms)
        ORDER BY id DESC;
SQL
}

cmd_shell() {
    preflight_check
    fail_unless_db_exists

    echo "${HISTORIAN_SQLITE3}" "${HISTORIAN_DB}" >&2
    historian_sqlite
}

cmd_version() {
    echo "historian version: ${VERSION}"
}

main() {
    local -r cmd=$1
    shift
    case $cmd in
    "" | "-h" | "--help")
        usage
        ;;
    /*)
        # Strip trailing slash and concatenate arguments together for short-hand search.
        cmd_search "$cmd" "${*:1}"
        ;;
    *)
        subcommand=cmd_${cmd}
        if typeset -rF "$subcommand"; then
            "$subcommand" "$@"
        else
            usage
            exit 1
        fi
        ;;
    esac
}

main "$@"
